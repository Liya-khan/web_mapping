<!DOCTYPE html>
<html>
<head>
    <title>Web Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Montserrat', sans-serif;
            color: #333;
        }

        #map-container {
            display: flex;
            height: 100vh;
        }

        #map {
            flex-grow: 1;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        /* Sidebar Styling */
        #sidebar {
            width: 350px;
            background-color: #f8f9fa;
            padding: 25px;
            box-shadow: -4px 0 15px rgba(0, 0, 0, 0.1);
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
            border-radius: 0 8px 8px 0;
        }

        .sidebar-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #ced4da;
        }

        .sidebar-header h2 {
            font-size: 2.2em;
            color: #495057;
            margin: 0;
            font-weight: 600;
        }

        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-section h3 {
            font-size: 1.3em;
            color: #6c757d;
            margin-bottom: 10px;
            font-weight: 500;
        }

        /* GeoJSON Display Styling */
        #geojson-display {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 0.8em;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            flex-grow: 1;
        }

        /* Download Elements Styling */
        .download-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .download-group select {
            flex-grow: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ced4da;
            font-family: 'Montserrat', sans-serif;
            font-size: 1em;
            background-color: #fff;
        }

        .btn {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            text-align: center;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
            border: none;
            cursor: pointer;
        }

        .btn:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div id="map-container">
        <div id="map"></div>
        <div id="sidebar">
            <div class="sidebar-header">
                <h2>Map Data & Analytics</h2>
            </div>


            <pre id="geojson-display">{}</pre>

            <div class="sidebar-section" style="margin-top: auto;">
                <div class="download-group">
                    <select id="download-format">
                        <option value="geojson">GeoJSON</option>
                        <option value="kml">KML</option>
                        <option value="csv">CSV</option>
                        <option value="shp-zip">Shapefile (.zip)</option>
                    </select>
                    <button id="download-btn" class="btn">Download</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <script>
        // Define base layers
        const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        });

        const esriWorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });

        const cartoDB = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        });

        // Initialize the map to show Asia with a default base layer
        const map = L.map('map', {
            center: [25, 80],
            zoom: 4,
            layers: [osm]
        });

        // This object will hold the last added marker
        let geocodedMarker = null;

        // Add the search bar to the map, positioned at the top right and opened by default
        L.Control.geocoder({
            position: 'topright',
            collapsed: false
        }).addTo(map);

        // Group the base layers for the layer control
        const baseMaps = {
            "OpenStreetMap": osm,
            "Satellite": esriWorldImagery,
            "Dark Theme": cartoDB
        };

        // Add the layer control to the map
        L.control.layers(baseMaps, null, { position: 'topright' }).addTo(map);

        // When a geocoded location is found, manually add a marker and pan the map
        map.on('markgeocode', function(e) {
            // Remove the previous marker if it exists
            if (geocodedMarker) {
                map.removeLayer(geocodedMarker);
            }
            // Add a new marker and store a reference to it
            geocodedMarker = L.marker(e.geocode.center).addTo(map);
            map.fitBounds(e.geocode.bbox);
        });

        // When the geocoder search is cleared, remove the marker
        map.on('geocoderclear', function() {
            if (geocodedMarker) {
                map.removeLayer(geocodedMarker);
                geocodedMarker = null; // Clear the reference
            }
        });

        // Feature Group to store all drawn items
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        // Initialize the draw control
        const drawControl = new L.Control.Draw({
            edit: {
                featureGroup: drawnItems
            },
            draw: {
                polygon: true,
                polyline: false,
                rectangle: false,
                circle: false,
                marker: false,
                circlemarker: false,
            }
        });
        map.addControl(drawControl);

        // Get sidebar elements
        const geojsonDisplay = document.getElementById('geojson-display');
        const downloadBtn = document.getElementById('download-btn');
        const downloadFormat = document.getElementById('download-format');

        // Function to convert GeoJSON to KML
        function geojsonToKml(geojson) {
            let kml = '<?xml version="1.0" encoding="UTF-8"?>' +
                      '<kml xmlns="http://www.opengis.net/kml/2.2">' +
                      '<Document>';

            geojson.features.forEach(feature => {
                const type = feature.geometry.type;
                const coords = feature.geometry.coordinates;

                if (type === 'Polygon') {
                    const polygonCoords = coords[0].map(c => `${c[0]},${c[1]},0`).join(' ');
                    kml += `<Placemark><Polygon><outerBoundaryIs><LinearRing><coordinates>${polygonCoords}</coordinates></LinearRing></outerBoundaryIs></Polygon></Placemark>`;
                }
            });

            kml += '</Document></kml>';
            return kml;
        }

        // Function to convert GeoJSON to CSV
        function geojsonToCsv(geojson) {
            let csv = 'Latitude,Longitude,Type\n';
            geojson.features.forEach(feature => {
                const type = feature.geometry.type;
                if (type === 'Polygon') {
                    feature.geometry.coordinates[0].forEach(c => {
                        csv += `${c[1]},${c[0]},${type}\n`;
                    });
                }
            });
            return csv;
        }

        // Function to update the sidebar and get GeoJSON
        function updateGeojson() {
            const allDrawnGeoJson = drawnItems.toGeoJSON();
            geojsonDisplay.textContent = JSON.stringify(allDrawnGeoJson, null, 2);
            return allDrawnGeoJson;
        }

        // Handle the single download button
        downloadBtn.addEventListener('click', function() {
            const allDrawnGeoJson = updateGeojson();
            if (allDrawnGeoJson.features.length === 0) {
                alert('Please draw some features first!');
                return;
            }

            const format = downloadFormat.value;

            if (format === 'geojson') {
                const geojsonBlob = new Blob([JSON.stringify(allDrawnGeoJson, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(geojsonBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'drawn_features.geojson';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } else if (format === 'kml') {
                const kmlContent = geojsonToKml(allDrawnGeoJson);
                const kmlBlob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
                const url = URL.createObjectURL(kmlBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'drawn_features.kml';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } else if (format === 'csv') {
                const csvContent = geojsonToCsv(allDrawnGeoJson);
                const csvBlob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(csvBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'drawn_features.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } else if (format === 'shp-zip') {
                // Send the GeoJSON data to your server endpoint for Shapefile conversion
                fetch('/convert-to-shp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(allDrawnGeoJson)
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Server error');
                    }
                    return response.blob();
                })
                .then(blob => {
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = 'drawn_features.zip';
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                })
                .catch(error => {
                    console.error('Download failed:', error);
                    alert('Failed to download Shapefile. Please ensure the server is running and configured correctly.');
                });
            }
        });

        // Listen for the 'draw:created' event
        map.on('draw:created', function(e) {
            const layer = e.layer;
            drawnItems.addLayer(layer);
            updateGeojson();
        });

        // Listen for the 'draw:edited' and 'draw:deleted' events
        map.on('draw:edited', updateGeojson);
        map.on('draw:deleted', updateGeojson);

        // Initial update for empty map
        updateGeojson();
    </script>
</body>
</html>
